<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Luca Simonetti">
<meta name="dcterms.date" content="2025-02-07">

<title>Hashing: Che Cos’è ’sto Hashing? – L.</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-a973770d809960bcbda85a0f6824f60f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Hashing: Che Cos’è ’sto Hashing?">
<meta property="og:description" content="L’hashing spiegato, spero, senza farvi venire il mal di testa.">
<meta property="og:image" content="https://theghoul21.github.io//images/hashing.jpeg">
<meta property="og:site_name" content="L.">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">L.</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects/index.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lecture-notes" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lecture notes</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lecture-notes">    
        <li>
    <a class="dropdown-item" href="https://theghoul21.github.io/CIT-2024-2025/" target="_blank">
 <span class="dropdown-text">Complexity and Information Theory 2024/2025</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://theghoul21.github.io/DL-2024-2025/" target="_blank">
 <span class="dropdown-text">Deep Learning 2024/2025</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://theghoul21.github.io/RO-2024-2025/" target="_blank">
 <span class="dropdown-text">Ricerca Operativa 2024/2025</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://theghoul21.github.io/FNN-2024-2025/" target="_blank">
 <span class="dropdown-text">Foundations of Neural Networks 2024/2025</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://theghoul21.github.io/QC-2023-2024/" target="_blank">
 <span class="dropdown-text">Quantum Computing 2023/2024</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://theghoul21.github.io/MB-2024-2025/" target="_blank">
 <span class="dropdown-text">Biologia Molecolare 2024/2025</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://theghoul21.github.io/VVT-2024-2025/" target="_blank">
 <span class="dropdown-text">Verification and Validation Techniques 2024/2025</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://theghoul21.github.io/AR-2024-2025/" target="_blank">
 <span class="dropdown-text">Automated Reasoning 2024/2025</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://theghoul21.github.io/AA-2023-2024/" target="_blank">
 <span class="dropdown-text">Advanced Algorithms 2023/2024</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">Hashing: Che Cos’è ’sto Hashing?</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">computer science</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Luca Simonetti </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 7, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#hashing-che-cazzo-è-sto-hashing" id="toc-hashing-che-cazzo-è-sto-hashing" class="nav-link active" data-scroll-target="#hashing-che-cazzo-è-sto-hashing">Hashing: Che Cazzo È ’sto Hashing?</a>
  <ul class="collapse">
  <li><a href="#che-cosè-in-parole-povere-lhashing" id="toc-che-cosè-in-parole-povere-lhashing" class="nav-link" data-scroll-target="#che-cosè-in-parole-povere-lhashing">Che Cos’è, in Parole Povere, l’Hashing?</a></li>
  <li><a href="#ma-a-che-cazzo-serve-veramente-lhashing" id="toc-ma-a-che-cazzo-serve-veramente-lhashing" class="nav-link" data-scroll-target="#ma-a-che-cazzo-serve-veramente-lhashing">Ma a Che Cazzo Serve Veramente l’Hashing?</a></li>
  <li><a href="#non-è-tutto-rose-e-fiori-o-hash-e-fiori-in-questo-caso" id="toc-non-è-tutto-rose-e-fiori-o-hash-e-fiori-in-questo-caso" class="nav-link" data-scroll-target="#non-è-tutto-rose-e-fiori-o-hash-e-fiori-in-questo-caso">Non è Tutto Rose e Fiori (o Hash e Fiori, in Questo Caso)</a></li>
  <li><a href="#quindi" id="toc-quindi" class="nav-link" data-scroll-target="#quindi">Quindi</a></li>
  <li><a href="#post-scriptum-hash-di-sto-articolo" id="toc-post-scriptum-hash-di-sto-articolo" class="nav-link" data-scroll-target="#post-scriptum-hash-di-sto-articolo">Post Scriptum: Hash di ’Sto Articolo</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="hashing-che-cazzo-è-sto-hashing" class="level1">
<h1>Hashing: Che Cazzo È ’sto Hashing?</h1>
<p>Se hai mai sentito parlare di password, sicurezza informatica o anche solo di blockchain (di cui abbiamo parlato la settimana scorsa, se te lo sei perso sei un pirla), probabilmente ti sei imbattuto in questa parola: <strong>hashing</strong>. Ma che cavolo è sta roba? Sembra il nome di una nuova droga sintetica o di un ballo di gruppo degli anni ’80. In realtà, è una figata (nel senso buono, non come quando ti dicono “che figata le tue Crocs 😐”). In questo articolo voglio spiegare (spero) in parole semplici cosa è l’hashing, perché è importante e perché conviene smettere di usare password di merda come “password123”.</p>
<section id="che-cosè-in-parole-povere-lhashing" class="level2">
<h2 class="anchored" data-anchor-id="che-cosè-in-parole-povere-lhashing">Che Cos’è, in Parole Povere, l’Hashing?</h2>
<p>Partiamo dalle basi, come quando a scuola di cucina ti spiegano come si le uova fritte (eppure, ahimé, anche riesce a fare un disastro…).</p>
<p>Immagina di avere una di quelle macchinette per fare la carne trita, hai presente? Ci metti dentro un pezzo di carne, giri la manovella e dall’altra parte esce carne trita. Ecco, <strong>l’hashing è un po’ come quella macchinetta, ma per i dati</strong>.</p>
<blockquote class="blockquote">
<p>Ah, figo, quindi se ci metto dentro un PDF esce… un PDF tritato?</p>
</blockquote>
<p>Minchia, sei simpatico, ti ucciderò per ultimo. No, non proprio. Non trita i dati nel senso che li spezzetta. Ma in un certo senso li trasforma. La macchinetta dell’hashing prende qualsiasi tipo di dato (un testo, un’immagine, un video, un file intero, la tua lista di maleducate) e lo trasforma in una stringa (una sequnza, ma in gergo si chiama stringa) di caratteri di lunghezza fissa, che all’apparenza è completamente casuale. Questa stringa (sequenza) di caratteri è chiamata <strong>hash</strong> (o “valore hash”, o “digest”, insomma, chiamala come cazzo ti pare, basta che ci capiamo).</p>
<blockquote class="blockquote">
<p>Ok, ok, ci sono quasi. Ma perché dovrebbe servirmi trasformare i miei dati in una stringa di caratteri a caso? Che me ne faccio? Ci tappezzo il cesso?</p>
</blockquote>
<p>Calma, non fare il fenomeno, che cazzo hai mangiato a colazione?! L’hash ha delle proprietà molto particolari che lo rendono decisamente utile. In ordine (o no?):</p>
<ol type="1">
<li><p><strong>È Deterministico:</strong> Se prendi lo stesso dato e lo passi alla stessa “macchinetta” (funzione di hash), otterrai <strong>sempre</strong> lo stesso identico hash. Sempre. Non importa quante volte lo fai, il risultato sarà sempre lo stesso. È come se la macchinetta avesse una memoria di ferro.</p>
<blockquote class="blockquote">
<p>Quindi se faccio l’hash della parola “ciao” ottengo sempre lo stesso hash?</p>
</blockquote>
<p>Esatto. Prova. Ci sono un sacco di siti online che fanno hash. Cerca “online hash calculator”, mettici “ciao” e usa l’algoritmo SHA-256 (uno dei più comuni). Vedrai che ti uscirà sempre la stessa stringa di caratteri (tipo <code>b133a0c0e9bee3be20163d2ad31d6248db292aa6dcb1ee087a2aa50e0fc75ae2</code>, ma non ti fissare con questa stringa, è solo un esempio).</p></li>
<li><p><strong>È One-Way (A Senso Unico):</strong> Questa è la parte <strong>veramente</strong> interessante e importante. È <strong>praticamente impossibile</strong> (e dico <em>praticamente</em> perché nella vita nulla è impossibile al 100%, tranne forse te che te ne stai a casa il sabato sera invece di andare a far baldoria con Salvini) <strong>tornare indietro dall’hash al dato originale</strong>. Cioè, se hai l’hash, non puoi in alcun modo (se non per forza bruta) ricostruire il dato di partenza. È come la macchinetta della carne trita: puoi fare la carne trita dalla carne, ma non puoi rifare il pezzo di carne dalla carne trita. Chiaro no?</p>
<blockquote class="blockquote">
<p>Sì, sì, ho capito. Quindi se io faccio l’hash della mia password “password123”, anche se qualcuno ruba l’hash, non può risalire alla mia password?</p>
</blockquote>
<p>YES! Finalmente hai detto una roba giusta, porca troia. Ed è proprio per questo che l’hashing è fondamentale per la sicurezza delle password. Quando ti registri su un sito web e scegli una password, il sito non salva la tua password <em>originale</em> (sarebbe da cretini, se lo fanno prendi un martello). Bensì, salva <strong>solo l’hash della tua password</strong>. Quando poi fai il login e inserisci la tua password, il sito calcola l’hash della password che hai inserito e lo confronta con l’hash che ha salvato. Se i due hash coincidono, significa che hai inserito la password giusta, senza che il sito abbia mai dovuto conoscere la tua password in chiaro. Così l’unico che in teoria sa la tua password sei tu (e la tua morosa…).</p></li>
<li><p><strong>È Resistente alle Collisioni (Idealmente, come sempre):</strong> Questa è un po’ più complicata, ma cercherò di semplificare al massimo. Idealmente (ovvero nei mondi con le fate, le lucine eccetera), è <strong>estremamente improbabile</strong> che due dati diversi producano lo stesso hash. Si chiama “collisione” quando due dati diversi producono lo stesso hash. Una buona funzione di hash è progettata per rendere le collisioni <strong>praticamente impossibili</strong> (di nuovo, <em>praticamente</em>). È come dire che è quasi impossibile che due pezzi di carne diversi, messi nella stessa macchinetta, producano esattamente la stessa carne trita. Capito no? Più o meno dai…</p>
<blockquote class="blockquote">
<p>Più o meno… Ma quindi le collisioni possono succedere?</p>
</blockquote>
<p>Sì, in teoria (e badate, che le cose che possono succedere in teoria anche con probabilità infime sono tante. Tipo che morite in un incidente d’auto, così, per dire.) possono succedere, ma con le funzioni di hash moderne e robuste, la probabilità è talmente bassa che è come vincere la lotteria 10 volte di fila mentre ti cade un meteorite in testa e Salvini dice una roba sensata. Insomma, per scopi pratici, possiamo dire che le collisioni sono <strong>trascurabili</strong>. Esistono però funzioni di hash più vecchie e meno sicure che sono più vulnerabili alle collisioni, ma c’è già troppa carne al fuoco (pun intended).</p></li>
</ol>
<p><strong>Ricapitolandolo:</strong></p>
<p>Quindi, ricapitolando, l’hashing è:</p>
<ul>
<li><strong>Una macchinetta per i dati:</strong> Prende qualsiasi dato e lo trasforma in una stringa di caratteri di lunghezza fissa (hash).</li>
<li><strong>Deterministico:</strong> Stesso dato, stesso hash, sempre.</li>
<li><strong>One-Way:</strong> Impossibile (praticamente) tornare indietro dall’hash al dato originale.</li>
<li><strong>Resistente alle Collisioni:</strong> Improbabile (molto improbabile) che due dati diversi producano lo stesso hash.</li>
</ul>
</section>
<section id="ma-a-che-cazzo-serve-veramente-lhashing" class="level2">
<h2 class="anchored" data-anchor-id="ma-a-che-cazzo-serve-veramente-lhashing">Ma a Che Cazzo Serve Veramente l’Hashing?</h2>
<p>Ok, abbiamo capito che cos’è l’hashing e le sue proprietà magiche. Ma in pratica, a cosa serve? Oltre a proteggere le password (che è già una figata non da poco), l’hashing ha un sacco di altre applicazioni. Eccone alcune:</p>
<ol type="1">
<li><p><strong>Verifica dell’Integrità dei Dati:</strong> Immagina di scaricare un file enorme da internet, tipo un film in HD o un videogioco. Come fai a essere sicuro che il file che hai scaricato sia integro e non sia stato corrotto durante il download? Semplice: il sito web da cui hai scaricato il file di solito fornisce anche l’<strong>hash del file</strong>. Tu, dopo aver scaricato il file, puoi calcolare l’hash del file scaricato e confrontarlo con l’hash fornito dal sito. Se i due hash coincidono, significa che il file è integro al 100%. Se non coincidono, significa che c’è stato un problema durante il download e il file è corrotto (o peggio, potrebbe essere stato manomesso da qualcuno). È come avere un sigillo di garanzia digitale sul file. Figata, no?</p></li>
<li><p><strong>Blockchain e Criptovalute:</strong> Se hai letto l’articolo sulla blockchain (e se non l’hai fatto, vergognati, tanto.), sai che l’hashing è un ingrediente fondamentale della blockchain. Viene usato per creare l’“impronta digitale” di ogni blocco e per collegare i blocchi in una catena immutabile. Senza l’hashing, la blockchain non esisterebbe. Quindi, se ti piacciono le criptovalute (o se le odi, non importa), sappi che devi ringraziare (o maledire) l’hashing.</p></li>
<li><p><strong>Firme Digitali:</strong> L’hashing è anche usato nelle firme digitali per garantire l’autenticità e l’integrità dei documenti digitali. Quando firmi digitalmente un documento, in realtà stai firmando l’hash del documento, non il documento intero. Questo rende la firma molto più efficiente e sicura.</p></li>
<li><p><strong>Ricerca Efficiente di Dati:</strong> L’hashing può essere usato per creare delle “tabelle hash” (o “hash map”), che sono delle strutture dati che permettono di cercare dati in modo molto veloce. È un po’ come avere un indice di un libro: invece di dover sfogliare tutto il libro per trovare un’informazione, puoi consultare l’indice e trovarla subito.</p></li>
</ol>
</section>
<section id="non-è-tutto-rose-e-fiori-o-hash-e-fiori-in-questo-caso" class="level2">
<h2 class="anchored" data-anchor-id="non-è-tutto-rose-e-fiori-o-hash-e-fiori-in-questo-caso">Non è Tutto Rose e Fiori (o Hash e Fiori, in Questo Caso)</h2>
<p>Anche l’hashing, come tutte le cose belle della vita, tipo me, ha i suoi limiti:</p>
<ol type="1">
<li><p><strong>Collisioni (anche se improbabili):</strong> Abbiamo detto che le collisioni sono <em>molto</em> improbabili, ma <em>non</em> impossibili. In teoria, un attaccante potrebbe cercare di trovare due dati diversi che producono lo stesso hash (un “attacco di collisione”). Se ci riuscisse, potrebbe usare questa collisione per scopi malevoli, tipo sostituire un file legittimo con uno fasullo che ha lo stesso hash. Per fortuna, trovare collisioni per le funzioni di hash moderne e robuste è estremamente difficile e costoso, ma è un rischio teorico da tenere presente.</p></li>
<li><p><strong>Attacchi di “Rainbow Table” e “Brute Force” alle Password:</strong> Anche se l’hashing rende difficile risalire alla password originale dall’hash, non è una protezione infallibile al 100%. Esistono tecniche come gli attacchi di “rainbow table” e “brute force” che possono essere usate per cercare di “indovinare” le password a partire dagli hash. Le “rainbow table” sono delle tabelle precalcolate che contengono gli hash di milioni di password comuni. Gli attacchi “brute force” invece consistono nel provare a calcolare l’hash di tutte le possibili password finché non si trova una corrispondenza con l’hash rubato. Per difendersi da questi attacchi, è fondamentale usare password <strong>lunghe, complesse e diverse per ogni sito</strong>. E smettetela di usare “password123”, che cazzo!</p></li>
<li><p><strong>Non è Crittografia:</strong> È importante capire che l’hashing <strong>non è crittografia</strong>. La crittografia serve per <em>nascondere</em> i dati, rendendoli illeggibili a chi non ha la chiave giusta. L’hashing serve per creare un’impronta digitale dei dati, per verificarne l’integrità e l’autenticità. E’ importante non confondere le due cose. È come confondere un lucchetto (crittografia) con un sigillo di ceralacca (hashing). Entrambi servono per la sicurezza, ma in modi diversi.</p></li>
</ol>
</section>
<section id="quindi" class="level2">
<h2 class="anchored" data-anchor-id="quindi">Quindi</h2>
<p>L’hashing è una tecnologia che sta alla base nel mondo digitale di oggi e di un sacco di cose che usiamo tutti i giorni, dalle password alla blockchain, dalla verifica dell’integrità dei file alle firme digitali. È una tecnologia potente e versatile, ma è importante conoscerne anche i limiti e le potenziali vulnerabilità.</p>
<p>La prossima volta che sentirai parlare di hashing pensa alla macchinetta per la carne trita dei dati, alla one-way, e alla sicurezza che può garantire. E soprattutto, smettila di usare password di merda! Grazie per l’attenzione e alla prossima settimana con un altro argomento nerd e (spero) interessante.</p>
</section>
<section id="post-scriptum-hash-di-sto-articolo" class="level2">
<h2 class="anchored" data-anchor-id="post-scriptum-hash-di-sto-articolo">Post Scriptum: Hash di ’Sto Articolo</h2>
<p>Giusto per fare i fighi e per farti capire ancora meglio la potenza dell’hashing, ho calcolato l’hash SHA-256 di questo articolo (in formato testo semplice, senza HTML o altre formattazioni). Ecco l’hash:</p>
<p><code>31e452bbf5134ac1d0d0a3a5897359b83eaccf6a46aed7d4323ddb51ec2d76f0</code></p>
<p>Ora, se io modificassi anche solo una virgola di questo articolo, anche solo uno spazio bianco, anche solo una lettera, l’hash <strong>cambierebbe completamente</strong>. Questo dimostra quanto anche una piccola modifica al dato originale cambi radicalmente l’hash. È proprio questa proprietà che rende l’hashing così utile per la verifica dell’integrità dei dati. E anche per farmi sentire un grande (imbecille) a scrivere un post scriptum del genere. Ciao stelline!</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/theghoul21\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2025, Luca Simonetti</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>