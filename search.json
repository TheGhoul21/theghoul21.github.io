[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "blog/sss.html",
    "href": "blog/sss.html",
    "title": "Shamir’s Secret Sharing",
    "section": "",
    "text": "Shamir’s Secret Sharing\nIn questo articolo mi voglio concentrare su una spiegazione (speriamo) dettagliata dell’algoritmo Shamir’s Secret Sharing, provando ad illustrare sia la parte più teorica che quella un po’ più pratica con degli esempi concreti. Allacciamo le cinture.\nFirst things first…\nLo Shamir’s Secret Sharing è innanzitutto un algoritmo di secret sharing crittografico ideato da Adi Shamir nel 1979. Permette di dividere un segreto \\(S\\) (poi ci arriviamo a che cazpita si intende con un segreto) in \\(n\\) parti, chiamate shares (parti?), in maniera tale che, per ricostruire il segreto (aridajela) originale, sia necessario un numero minimo \\(k\\) (con \\(k \\leq n\\)) di queste shares. Questo schema è anche conosciuto come threshold scheme \\((k, n)\\).\nQuindi:\n\nUn segreto viene diviso in \\(n\\) shares.\nAlmeno \\(k\\) shares sono necessarie per ricostruire l’intero segreto (magia).\nCon meno di \\(k\\) shares, il segreto non può essere ricostruito (volevi eh!?), e non si ottiene alcuna informazione su di esso (proprietà di information-theoretically secure).\n\nA che serve:\n\nKey Management: Distribuire una master key crittografica tra più attori, in modo che un numero sufficiente di essi debba cooperare per utilizzarla.\nAccess Control: Dividere una secret key per l’accesso a un sistema o a dei dati tra più utenti.\nDistributed Storage: Distribuire i frammenti di un file criptato su più server, in modo che un certo numero di server debba essere accessibile per decriptare il file.\nSecure Multi-Party Computation (MPC): Come building block per protocolli più complessi.\nDividere i vocali della chat coi bro: Così andiamo tutti in galera, non solo io.\n\nIn sostanza: un segreto è qualcosa che vogliamo proteggere. Per esempio può essere una chiave privata (una password dai… senza fare tanto il fenomeno). Però vogliamo che non risieda in un unico punto bensì che risieda in tanti luoghi fisici diversi. Per esempio un pezzo lo nascondo a casa mia, un pezzo dal salumiere, un pezzo dal gommista eccetera eccetera eccetera.\nA sto punto però prima o poi la password mi serve e visto che io ho la memoria di un pesce rosso devo andare dal salumiere. Ma lo trovo chiuso. E adesso? sono fottuto. Mi serve la mia password per comprare i filmini con le donne nude, come faccio?\nEh come faccio… Con lo schema di Shamir’s non mi serve avere accesso a tutte le share, bensì solo a un gruppo di esse. Ed è qui appunto la magia.\nCome funziona?\nA livello puramente matematico, l’algoritmo si basa sull’interpolation polinomiale. L’idea chiave è che, dati \\(k\\) punti in un piano, con ascisse distinte, esiste uno e un solo polinomio di grado al più \\(k-1\\) che passa per tutti questi punti. Nel nostro caso, il grado del polinomio sarà esattamente \\(k-1\\).\nEsempio con polinomio di grado 2 (k=3):\nPer ricostruire un polinomio di grado 2 (una parabola), sono necessari \\(k=3\\) punti. Qui sotto puoi interagire con un grafico che mostra questo concetto. Muovi i punti e osserva come cambia la parabola. Il termine noto del polinomio (il punto in cui la parabola interseca l’asse y) rappresenta il segreto.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nfrom IPython.display import display, clear_output\n\nimport plotly.io as pio\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\n\n# Area di output per il grafico\noutput = widgets.Output()\n\n# Funzione per aggiornare il plot\ndef update_plot(x1, y1, x2, y2, x3, y3):\n    with output:\n        clear_output(wait=True)  # Cancella il vecchio plot\n\n        # Punti selezionati\n        x_points = np.array([x1, x2, x3])\n        y_points = np.array([y1, y2, y3])\n\n        # Interpolazione polinomiale (grado 2)\n        coeffs = np.polyfit(x_points, y_points, 2)  # ax² + bx + c\n\n        # Generazione della parabola\n        x = np.linspace(-5, 5, 200)\n        y = np.polyval(coeffs, x)\n\n        # Plot\n        plt.figure(figsize=(8, 6))\n        plt.plot(x, y, label=f\"y = {coeffs[0]:.2f}x² + {coeffs[1]:.2f}x + {coeffs[2]:.2f}\")\n        plt.scatter(x_points, y_points, color='red', s=100, label=\"Punti di interpolazione\")\n        plt.axhline(0, color='black', linewidth=0.5)\n        plt.axvline(0, color='black', linewidth=0.5)\n        plt.grid(True)\n        \n        # Titolo con il valore segreto\n        plt.title(f\"Segreto: {coeffs[2]:.2f}\")\n        plt.xlabel(\"x\")\n        plt.ylabel(\"y\")\n        plt.legend()\n        plt.show()\n\n# Slider interattivi\nx1 = widgets.FloatSlider(min=-4, max=4, step=0.5, value=-2, description='x1')\ny1 = widgets.FloatSlider(min=-5, max=5, step=0.5, value=4, description='y1')\nx2 = widgets.FloatSlider(min=-4, max=4, step=0.5, value=2, description='x2')\ny2 = widgets.FloatSlider(min=-5, max=5, step=0.5, value=-4, description='y2')\nx3 = widgets.FloatSlider(min=-4, max=4, step=0.5, value=3, description='x3')\ny3 = widgets.FloatSlider(min=-5, max=5, step=0.5, value=4, description='y3')\n\n# # Collega gli slider alla funzione di aggiornamento\nui = widgets.VBox([x1, y1, x2, y2, x3, y3])\n# interactive_plot = widgets.interactive(update_plot, x1=x1, y1=y1, x2=x2, y2=y2, x3=x3, y3=y3)\n\n# # Mostra UI e output\ndisplay(ui, output)\n\n# Inizializza il grafico\nupdate_plot(x1.value, y1.value, x2.value, y2.value, x3.value, y3.value)\n\n\n\nMuovi i punti per vedere come cambia la parabola. Il punto di intersezione con l’asse y è il segreto.\n\n\n\n\n\nFasi dell’algoritmo:\n\nSetup:\n\nSia \\(S\\) il segreto da condividere, rappresentato come un numero intero.\nSia \\(n\\) il numero di shares da generare.\nSia \\(k\\) il threshold, ovvero il numero minimo di shares necessarie per ricostruire il segreto.\nScegli un numero primo \\(p\\) maggiore di \\(S\\) e di \\(n\\). Tutte le operazioni aritmetiche saranno eseguite modulo \\(p\\) (in \\(\\mathbb{Z}_p\\)).\n\nShare Generation:\n\nScegli casualmente \\(k-1\\) coefficienti \\(a_1, a_2, \\dots, a_{k-1}\\), dove ogni \\(a_i\\) è un numero intero in \\(\\mathbb{Z}_p\\).\nCostruisci il polinomio \\(P(x)\\) di grado \\(k-1\\):\n\n\\[P(x) = S + a_1x + a_2x^2 + \\dots + a_{k-1}x^{k-1}\\]\n\nNotare che il termine noto del polinomio è il segreto \\(S\\) (\\(P(0) = S\\)).\nGenera \\(n\\) shares calcolando il valore del polinomio in \\(n\\) punti distinti non nulli. Ad esempio, si possono usare i punti \\(x = 1, 2, \\dots, n\\).\nLa share \\(i\\)-esima è la coppia \\((x_i, y_i)\\), dove \\(x_i = i\\) e \\(y_i = P(i)\\).\n\nSecret Reconstruction:\n\nPer ricostruire il segreto, sono necessarie almeno \\(k\\) shares \\((x_i, y_i)\\).\nUtilizza l’interpolation di Lagrange per ricostruire il polinomio \\(P(x)\\) a partire dai \\(k\\) punti. La formula di Lagrange è:\n\n\\[P(x) = \\sum_{i=1}^{k} y_i \\prod_{j=1, j \\neq i}^{k} \\frac{x - x_j}{x_i - x_j}\\]\n\nUna volta ricostruito il polinomio \\(P(x)\\), il segreto \\(S\\) può essere ottenuto valutando il polinomio in \\(x=0\\):\n\n\\[S = P(0)\\]\n\nEsempio (semplificato):\n\nSegreto: \\(S = 1234\\)\nNumero di shares: \\(n = 5\\)\nThreshold: \\(k = 3\\)\nNumero primo: \\(p = 1613\\) (maggiore di \\(S\\) e \\(n\\))\n\nShare Generation:\n\nScegliamo casualmente \\(k-1 = 2\\) coefficienti: \\(a_1 = 166\\), \\(a_2 = 94\\).\nIl polinomio è: \\(P(x) = 1234 + 166x + 94x^2\\).\nGeneriamo 5 shares:\n\n\\(P(1) = 1234 + 166 \\cdot 1 + 94 \\cdot 1^2 = 1494 \\pmod{1613}\\) -&gt; \\((1, 1494)\\)\n\\(P(2) = 1234 + 166 \\cdot 2 + 94 \\cdot 2^2 = 1942 \\equiv 329 \\pmod{1613}\\) -&gt; \\((2, 329)\\)\n\\(P(3) = 1234 + 166 \\cdot 3 + 94 \\cdot 3^2 = 2578 \\equiv 965 \\pmod{1613}\\) -&gt; \\((3, 965)\\)\n\\(P(4) = 1234 + 166 \\cdot 4 + 94 \\cdot 4^2 = 3402 \\equiv 176 \\pmod{1613}\\) -&gt; \\((4, 176)\\)\n\\(P(5) = 1234 + 166 \\cdot 5 + 94 \\cdot 5^2 = 4414 \\equiv 1188 \\pmod{1613}\\) -&gt; \\((5, 1188)\\)\n\n\nSecret Reconstruction:\nSupponiamo di avere le shares: \\((1, 1494)\\), \\((3, 965)\\), \\((5, 1188)\\).\n\nUsiamo l’interpolation di Lagrange per ricostruire il polinomio.\nDopo aver eseguito i calcoli (omessi per brevità), otteniamo \\(P(x) = 1234 + 166x + 94x^2\\).\nIl segreto è \\(S = P(0) = 1234\\).\n\nProprietà di sicurezza:\n\nInformation-Theoretically Secure: Con meno di \\(k\\) shares, non si ottiene alcuna informazione sul segreto. Questo perché qualsiasi valore del segreto è ugualmente probabile, dato un numero insufficiente di punti per determinare univocamente il polinomio.\nPerfect Secret Sharing: Ogni share è grande quanto il segreto originale.\n\nLimitazioni:\n\nShare Size: Ogni share ha la stessa dimensione del segreto. Questo può essere problematico se il segreto è molto grande, per esempio un file.\nDealer Trust: Il dealer (chi genera le shares) conosce il segreto e deve essere fidato. E dunque potenzialmente rende questo inusabile in contesti come blockchain dove si potrebbe volere uno schema meno lasco dove la chiave privata (il segreto) non viene mai veramente materializzata completamente.\nStatic Threshold: Il valore di \\(k\\) (il threshold) è fissato al momento della generazione delle shares. Ovvero se aumentano o diminuiscono i partecipanti bisogna rifare tutto sto giro da capo.\n\nConclusioni:\nWow. Che figata, loso. Lo Shamir’s Secret Sharing è alla fine un algoritmo decisamente potent per la condivisione di segreti o chiavi private. Nonostante alcune limitazioni, rimane uno schema fondamentale nel campo della crittografia e della sicurezza informatica."
  },
  {
    "objectID": "projects/connect4.html",
    "href": "projects/connect4.html",
    "title": "Connect 4",
    "section": "",
    "text": "Research & Development Diary\nVoglio applicare il metodo DPO a una rete RNN. Creerò una struttura composta da tre elementi che interagiscono tra loro:\n\nuna RNN che ha appreso solo le regole del gioco (banalmente sequenze di partite random)\nuna rete che apprende tramite DPO a discernere tra una mossa giusta e una sbagliata\nuna rete che apprende ad apprendere, che adatta i parametri della rete 1. in base alla situazione/stato corrente."
  },
  {
    "objectID": "projects/spatial-spike-neural-networks-it.html",
    "href": "projects/spatial-spike-neural-networks-it.html",
    "title": "Spatial Spike Neural Networks",
    "section": "",
    "text": "Ricerca e Sviluppo\nVoglio provare a studiare un tipo di rete neurale di cui non ho trovato citazioni in ambito di ricerca. Di base Una rete neurale spiking (SNN) è un tipo di Neural Network che si avvicina maggiormente al funzionamento dei neuroni biologici. A differenza delle reti neurali tradizionali che trasmettono valori continui (ovvero fanno le moltiplicazioni direttamente), le SNN elaborano le informazioni attraverso “spike”, ovvero eventi discreti nel tempo, rendendole computazionalmente più efficienti. Queste reti codificano le informazioni nella temporizzazione e nella frequenza degli spike, consentendo loro di catturare dinamiche temporali complesse e potenzialmente imitare la capacità di apprendimento del cervello.\nL’elemento che voglio introdurre è quello di strutture (basate su grafi) che includano all’interno della rete anche il concetto di vicinanza dei neuroni della rete. Voglio inoltre provare a comprendere se i neuroni possono spostarsi all’interno della struttura a grafo.\nIn altre parole: do una struttura alla rete, come ad esempio delle strutture simili a quelle cristalline, e posiziono i neuroni. Man mano che apprendono pattern all’interno dei dati, li faccio muovere seguendo la struttura data, seguendo l’apprendimento Hebbiano"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Research Projects",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nJan 30, 2025\n\n\nConnect 4\n\n\nLuca Simonetti\n\n\n\n\nJan 30, 2025\n\n\nSpatial Spike Neural Networks\n\n\nLuca Simonetti\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Luca Simonetti, yet another idiot",
    "section": "",
    "text": "Luca Simonetti\n\n\nJan 30, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#blog",
    "href": "index.html#blog",
    "title": "Luca Simonetti, yet another idiot",
    "section": "",
    "text": "Luca Simonetti\n\n\nJan 30, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#projects",
    "href": "index.html#projects",
    "title": "Luca Simonetti, yet another idiot",
    "section": "Projects",
    "text": "Projects\n\n\n\n\n\n\n\n\n\n\nConnect 4\n\n\n\n\n\n\nLuca Simonetti\n\n\nJan 30, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpatial Spike Neural Networks\n\n\n\n\n\n\nLuca Simonetti\n\n\nJan 30, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "L’s blog",
    "section": "",
    "text": "Shamir’s Secret Sharing\n\n\n\n\n\n\nprogramming\n\n\nweb development\n\n\n\n\n\n\n\n\n\nJan 30, 2025\n\n\nLuca Simonetti\n\n\n\n\n\n\nNo matching items"
  }
]