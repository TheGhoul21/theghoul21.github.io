{"title":"Shamir's Secret Sharing","markdown":{"yaml":{"title":"Shamir's Secret Sharing","author":"Luca Simonetti","date":"2025-01-30","categories":["programming","web development"]},"headingText":"Shamir's Secret Sharing","containsRefs":false,"markdown":"\nIn questo articolo mi voglio concentrare su una spiegazione (speriamo) dettagliata dell'algoritmo Shamir's Secret Sharing, provando ad illustrare sia la parte più teorica che quella un po' più pratica con degli esempi concreti.\nAllacciamo le cinture. \n\nFirst things first...\n\nLo Shamir's Secret Sharing è innanzitutto un algoritmo di **secret sharing** crittografico ideato da Adi Shamir nel 1979. Permette di dividere un segreto $S$ (poi ci arriviamo a che cazpita si intende con *un segreto*) in $n$ parti, chiamate **shares** (parti?), in maniera tale che, per ricostruire il segreto (aridajela) originale, sia necessario un numero minimo $k$ (con $k \\leq n$) di queste **shares**. Questo schema è anche conosciuto come **threshold scheme** $(k, n)$.\n\n\n**Quindi:**\n\n*   Un segreto viene *diviso* in $n$ **shares**.\n*   Almeno $k$ **shares** sono necessarie per ricostruire l'intero segreto (magia).\n*   Con meno di $k$ **shares**, il segreto non può essere ricostruito (volevi eh!?), e non si ottiene alcuna informazione su di esso (proprietà di **information-theoretically secure**).\n\n**A che serve:**\n\n*   **Key Management:** Distribuire una **master key** crittografica tra più attori, in modo che un numero sufficiente di essi debba cooperare per utilizzarla.\n*   **Access Control:** Dividere una **secret key** per l'accesso a un sistema o a dei dati tra più utenti.\n*   **Distributed Storage:** Distribuire i frammenti di un file criptato su più server, in modo che un certo numero di server debba essere accessibile per decriptare il file.\n*   **Secure Multi-Party Computation (MPC):** Come building block per protocolli più complessi.\n*   **Dividere i vocali della chat coi bro:** Così andiamo tutti in galera, non solo io.\n\n\nIn sostanza: un segreto è qualcosa che vogliamo proteggere. Per esempio può essere una chiave privata (una password dai... senza fare tanto il fenomeno). Però vogliamo che non risieda in un unico punto bensì che risieda in tanti luoghi fisici diversi. Per esempio un pezzo lo nascondo a casa mia, un pezzo dal salumiere, un pezzo dal gommista eccetera eccetera eccetera.\n\nA sto punto però prima o poi la password mi serve e visto che io ho la memoria di un pesce rosso devo andare dal salumiere. Ma lo trovo chiuso. E adesso? sono fottuto.\nMi serve la mia password per comprare i filmini con le donne nude, come faccio?\n\nEh come faccio... Con lo schema di Shamir's non mi serve avere accesso a tutte le share, bensì solo a un gruppo di esse. Ed è qui appunto la magia.\n\n**Come funziona?**\n\nA livello puramente matematico, l'algoritmo si basa sull'**interpolation** polinomiale. L'idea chiave è che, dati $k$ punti in un piano, con ascisse distinte, esiste uno e un solo polinomio di grado *al più* $k-1$ che passa per tutti questi punti. Nel nostro caso, il grado del polinomio sarà esattamente $k-1$.\n\n**Esempio con polinomio di grado 2 (k=3):**\n\nPer ricostruire un polinomio di grado 2 (una parabola), sono necessari $k=3$ punti. Qui sotto puoi interagire con un grafico che mostra questo concetto. Muovi i punti e osserva come cambia la parabola. Il termine noto del polinomio (il punto in cui la parabola interseca l'asse y) rappresenta il segreto.\n\n```{python}\n#| label: parabola-interattiva\n#| fig-cap: \"Muovi i punti per vedere come cambia la parabola. Il punto di intersezione con l'asse y è il segreto.\"\n#| code-fold: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nfrom IPython.display import display, clear_output\n\nimport plotly.io as pio\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\n\n# Area di output per il grafico\noutput = widgets.Output()\n\n# Funzione per aggiornare il plot\ndef update_plot(x1, y1, x2, y2, x3, y3):\n    with output:\n        clear_output(wait=True)  # Cancella il vecchio plot\n\n        # Punti selezionati\n        x_points = np.array([x1, x2, x3])\n        y_points = np.array([y1, y2, y3])\n\n        # Interpolazione polinomiale (grado 2)\n        coeffs = np.polyfit(x_points, y_points, 2)  # ax² + bx + c\n\n        # Generazione della parabola\n        x = np.linspace(-5, 5, 200)\n        y = np.polyval(coeffs, x)\n\n        # Plot\n        plt.figure(figsize=(8, 6))\n        plt.plot(x, y, label=f\"y = {coeffs[0]:.2f}x² + {coeffs[1]:.2f}x + {coeffs[2]:.2f}\")\n        plt.scatter(x_points, y_points, color='red', s=100, label=\"Punti di interpolazione\")\n        plt.axhline(0, color='black', linewidth=0.5)\n        plt.axvline(0, color='black', linewidth=0.5)\n        plt.grid(True)\n        \n        # Titolo con il valore segreto\n        plt.title(f\"Segreto: {coeffs[2]:.2f}\")\n        plt.xlabel(\"x\")\n        plt.ylabel(\"y\")\n        plt.legend()\n        plt.show()\n\n# Slider interattivi\nx1 = widgets.FloatSlider(min=-4, max=4, step=0.5, value=-2, description='x1')\ny1 = widgets.FloatSlider(min=-5, max=5, step=0.5, value=4, description='y1')\nx2 = widgets.FloatSlider(min=-4, max=4, step=0.5, value=2, description='x2')\ny2 = widgets.FloatSlider(min=-5, max=5, step=0.5, value=-4, description='y2')\nx3 = widgets.FloatSlider(min=-4, max=4, step=0.5, value=3, description='x3')\ny3 = widgets.FloatSlider(min=-5, max=5, step=0.5, value=4, description='y3')\n\n# # Collega gli slider alla funzione di aggiornamento\nui = widgets.VBox([x1, y1, x2, y2, x3, y3])\n# interactive_plot = widgets.interactive(update_plot, x1=x1, y1=y1, x2=x2, y2=y2, x3=x3, y3=y3)\n\n# # Mostra UI e output\ndisplay(ui, output)\n\n# Inizializza il grafico\nupdate_plot(x1.value, y1.value, x2.value, y2.value, x3.value, y3.value)\n```\n\n\n**Fasi dell'algoritmo:**\n\n1. **Setup:**\n    *   Sia $S$ il segreto da condividere, rappresentato come un numero intero.\n    *   Sia $n$ il numero di **shares** da generare.\n    *   Sia $k$ il **threshold**, ovvero il numero minimo di **shares** necessarie per ricostruire il segreto.\n    *   Scegli un numero primo $p$ maggiore di $S$ e di $n$. Tutte le operazioni aritmetiche saranno eseguite modulo $p$ (in $\\mathbb{Z}_p$).\n\n2. **Share Generation:**\n    *   Scegli casualmente $k-1$ coefficienti $a_1, a_2, \\dots, a_{k-1}$, dove ogni $a_i$ è un numero intero in $\\mathbb{Z}_p$.\n    *   Costruisci il polinomio $P(x)$ di grado $k-1$:\n\n    $$P(x) = S + a_1x + a_2x^2 + \\dots + a_{k-1}x^{k-1}$$\n\n    *   Notare che il termine noto del polinomio è il segreto $S$ ($P(0) = S$).\n    *   Genera $n$ **shares** calcolando il valore del polinomio in $n$ punti distinti non nulli. Ad esempio, si possono usare i punti $x = 1, 2, \\dots, n$.\n    *   La **share** $i$-esima è la coppia $(x_i, y_i)$, dove $x_i = i$ e $y_i = P(i)$.\n\n3. **Secret Reconstruction:**\n    *   Per ricostruire il segreto, sono necessarie almeno $k$ **shares** $(x_i, y_i)$.\n    *   Utilizza l'**interpolation** di Lagrange per ricostruire il polinomio $P(x)$ a partire dai $k$ punti. La formula di Lagrange è:\n\n    $$P(x) = \\sum_{i=1}^{k} y_i \\prod_{j=1, j \\neq i}^{k} \\frac{x - x_j}{x_i - x_j}$$\n\n    *   Una volta ricostruito il polinomio $P(x)$, il segreto $S$ può essere ottenuto valutando il polinomio in $x=0$:\n\n    $$S = P(0)$$\n\n**Esempio (semplificato):**\n\n*   Segreto: $S = 1234$\n*   Numero di **shares**: $n = 5$\n*   **Threshold**: $k = 3$\n*   Numero primo: $p = 1613$ (maggiore di $S$ e $n$)\n\n**Share Generation:**\n\n*   Scegliamo casualmente $k-1 = 2$ coefficienti: $a_1 = 166$, $a_2 = 94$.\n*   Il polinomio è: $P(x) = 1234 + 166x + 94x^2$.\n*   Generiamo 5 **shares**:\n    *   $P(1) = 1234 + 166 \\cdot 1 + 94 \\cdot 1^2 = 1494 \\pmod{1613}$  ->  $(1, 1494)$\n    *   $P(2) = 1234 + 166 \\cdot 2 + 94 \\cdot 2^2 = 1942 \\equiv 329 \\pmod{1613}$  ->  $(2, 329)$\n    *   $P(3) = 1234 + 166 \\cdot 3 + 94 \\cdot 3^2 = 2578 \\equiv 965 \\pmod{1613}$  ->  $(3, 965)$\n    *   $P(4) = 1234 + 166 \\cdot 4 + 94 \\cdot 4^2 = 3402 \\equiv 176 \\pmod{1613}$  ->  $(4, 176)$\n    *   $P(5) = 1234 + 166 \\cdot 5 + 94 \\cdot 5^2 = 4414 \\equiv 1188 \\pmod{1613}$ ->  $(5, 1188)$\n\n**Secret Reconstruction:**\n\nSupponiamo di avere le **shares**: $(1, 1494)$, $(3, 965)$, $(5, 1188)$.\n\n*   Usiamo l'**interpolation** di Lagrange per ricostruire il polinomio.\n*   Dopo aver eseguito i calcoli (omessi per brevità), otteniamo $P(x) = 1234 + 166x + 94x^2$.\n*   Il segreto è $S = P(0) = 1234$.\n\n**Proprietà di sicurezza:**\n\n*   **Information-Theoretically Secure:** Con meno di $k$ **shares**, non si ottiene alcuna informazione sul segreto. Questo perché qualsiasi valore del segreto è ugualmente probabile, dato un numero insufficiente di punti per determinare univocamente il polinomio.\n*   **Perfect Secret Sharing:** Ogni **share** è grande quanto il segreto originale.\n\n**Limitazioni:**\n\n*   **Share Size:** Ogni **share** ha la stessa dimensione del segreto. Questo può essere problematico se il segreto è molto grande, per esempio un file.\n*   **Dealer Trust:** Il **dealer** (chi genera le **shares**) conosce il segreto e deve essere fidato. E dunque potenzialmente rende questo inusabile in contesti come blockchain dove si potrebbe volere uno schema meno lasco dove la chiave privata (il segreto) non viene mai veramente materializzata completamente. \n*   **Static Threshold:** Il valore di $k$ (il **threshold**) è fissato al momento della generazione delle **shares**. Ovvero se aumentano o diminuiscono i partecipanti bisogna rifare tutto sto giro da capo.\n\n**Conclusioni:**\n\nWow. Che figata, loso. Lo Shamir's Secret Sharing è alla fine un algoritmo decisamente potent per la condivisione di segreti o chiavi private. Nonostante alcune limitazioni, rimane uno schema fondamentale nel campo della crittografia e della sicurezza informatica.\n","srcMarkdownNoYaml":"\n# Shamir's Secret Sharing\nIn questo articolo mi voglio concentrare su una spiegazione (speriamo) dettagliata dell'algoritmo Shamir's Secret Sharing, provando ad illustrare sia la parte più teorica che quella un po' più pratica con degli esempi concreti.\nAllacciamo le cinture. \n\nFirst things first...\n\nLo Shamir's Secret Sharing è innanzitutto un algoritmo di **secret sharing** crittografico ideato da Adi Shamir nel 1979. Permette di dividere un segreto $S$ (poi ci arriviamo a che cazpita si intende con *un segreto*) in $n$ parti, chiamate **shares** (parti?), in maniera tale che, per ricostruire il segreto (aridajela) originale, sia necessario un numero minimo $k$ (con $k \\leq n$) di queste **shares**. Questo schema è anche conosciuto come **threshold scheme** $(k, n)$.\n\n\n**Quindi:**\n\n*   Un segreto viene *diviso* in $n$ **shares**.\n*   Almeno $k$ **shares** sono necessarie per ricostruire l'intero segreto (magia).\n*   Con meno di $k$ **shares**, il segreto non può essere ricostruito (volevi eh!?), e non si ottiene alcuna informazione su di esso (proprietà di **information-theoretically secure**).\n\n**A che serve:**\n\n*   **Key Management:** Distribuire una **master key** crittografica tra più attori, in modo che un numero sufficiente di essi debba cooperare per utilizzarla.\n*   **Access Control:** Dividere una **secret key** per l'accesso a un sistema o a dei dati tra più utenti.\n*   **Distributed Storage:** Distribuire i frammenti di un file criptato su più server, in modo che un certo numero di server debba essere accessibile per decriptare il file.\n*   **Secure Multi-Party Computation (MPC):** Come building block per protocolli più complessi.\n*   **Dividere i vocali della chat coi bro:** Così andiamo tutti in galera, non solo io.\n\n\nIn sostanza: un segreto è qualcosa che vogliamo proteggere. Per esempio può essere una chiave privata (una password dai... senza fare tanto il fenomeno). Però vogliamo che non risieda in un unico punto bensì che risieda in tanti luoghi fisici diversi. Per esempio un pezzo lo nascondo a casa mia, un pezzo dal salumiere, un pezzo dal gommista eccetera eccetera eccetera.\n\nA sto punto però prima o poi la password mi serve e visto che io ho la memoria di un pesce rosso devo andare dal salumiere. Ma lo trovo chiuso. E adesso? sono fottuto.\nMi serve la mia password per comprare i filmini con le donne nude, come faccio?\n\nEh come faccio... Con lo schema di Shamir's non mi serve avere accesso a tutte le share, bensì solo a un gruppo di esse. Ed è qui appunto la magia.\n\n**Come funziona?**\n\nA livello puramente matematico, l'algoritmo si basa sull'**interpolation** polinomiale. L'idea chiave è che, dati $k$ punti in un piano, con ascisse distinte, esiste uno e un solo polinomio di grado *al più* $k-1$ che passa per tutti questi punti. Nel nostro caso, il grado del polinomio sarà esattamente $k-1$.\n\n**Esempio con polinomio di grado 2 (k=3):**\n\nPer ricostruire un polinomio di grado 2 (una parabola), sono necessari $k=3$ punti. Qui sotto puoi interagire con un grafico che mostra questo concetto. Muovi i punti e osserva come cambia la parabola. Il termine noto del polinomio (il punto in cui la parabola interseca l'asse y) rappresenta il segreto.\n\n```{python}\n#| label: parabola-interattiva\n#| fig-cap: \"Muovi i punti per vedere come cambia la parabola. Il punto di intersezione con l'asse y è il segreto.\"\n#| code-fold: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nfrom IPython.display import display, clear_output\n\nimport plotly.io as pio\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\n\n# Area di output per il grafico\noutput = widgets.Output()\n\n# Funzione per aggiornare il plot\ndef update_plot(x1, y1, x2, y2, x3, y3):\n    with output:\n        clear_output(wait=True)  # Cancella il vecchio plot\n\n        # Punti selezionati\n        x_points = np.array([x1, x2, x3])\n        y_points = np.array([y1, y2, y3])\n\n        # Interpolazione polinomiale (grado 2)\n        coeffs = np.polyfit(x_points, y_points, 2)  # ax² + bx + c\n\n        # Generazione della parabola\n        x = np.linspace(-5, 5, 200)\n        y = np.polyval(coeffs, x)\n\n        # Plot\n        plt.figure(figsize=(8, 6))\n        plt.plot(x, y, label=f\"y = {coeffs[0]:.2f}x² + {coeffs[1]:.2f}x + {coeffs[2]:.2f}\")\n        plt.scatter(x_points, y_points, color='red', s=100, label=\"Punti di interpolazione\")\n        plt.axhline(0, color='black', linewidth=0.5)\n        plt.axvline(0, color='black', linewidth=0.5)\n        plt.grid(True)\n        \n        # Titolo con il valore segreto\n        plt.title(f\"Segreto: {coeffs[2]:.2f}\")\n        plt.xlabel(\"x\")\n        plt.ylabel(\"y\")\n        plt.legend()\n        plt.show()\n\n# Slider interattivi\nx1 = widgets.FloatSlider(min=-4, max=4, step=0.5, value=-2, description='x1')\ny1 = widgets.FloatSlider(min=-5, max=5, step=0.5, value=4, description='y1')\nx2 = widgets.FloatSlider(min=-4, max=4, step=0.5, value=2, description='x2')\ny2 = widgets.FloatSlider(min=-5, max=5, step=0.5, value=-4, description='y2')\nx3 = widgets.FloatSlider(min=-4, max=4, step=0.5, value=3, description='x3')\ny3 = widgets.FloatSlider(min=-5, max=5, step=0.5, value=4, description='y3')\n\n# # Collega gli slider alla funzione di aggiornamento\nui = widgets.VBox([x1, y1, x2, y2, x3, y3])\n# interactive_plot = widgets.interactive(update_plot, x1=x1, y1=y1, x2=x2, y2=y2, x3=x3, y3=y3)\n\n# # Mostra UI e output\ndisplay(ui, output)\n\n# Inizializza il grafico\nupdate_plot(x1.value, y1.value, x2.value, y2.value, x3.value, y3.value)\n```\n\n\n**Fasi dell'algoritmo:**\n\n1. **Setup:**\n    *   Sia $S$ il segreto da condividere, rappresentato come un numero intero.\n    *   Sia $n$ il numero di **shares** da generare.\n    *   Sia $k$ il **threshold**, ovvero il numero minimo di **shares** necessarie per ricostruire il segreto.\n    *   Scegli un numero primo $p$ maggiore di $S$ e di $n$. Tutte le operazioni aritmetiche saranno eseguite modulo $p$ (in $\\mathbb{Z}_p$).\n\n2. **Share Generation:**\n    *   Scegli casualmente $k-1$ coefficienti $a_1, a_2, \\dots, a_{k-1}$, dove ogni $a_i$ è un numero intero in $\\mathbb{Z}_p$.\n    *   Costruisci il polinomio $P(x)$ di grado $k-1$:\n\n    $$P(x) = S + a_1x + a_2x^2 + \\dots + a_{k-1}x^{k-1}$$\n\n    *   Notare che il termine noto del polinomio è il segreto $S$ ($P(0) = S$).\n    *   Genera $n$ **shares** calcolando il valore del polinomio in $n$ punti distinti non nulli. Ad esempio, si possono usare i punti $x = 1, 2, \\dots, n$.\n    *   La **share** $i$-esima è la coppia $(x_i, y_i)$, dove $x_i = i$ e $y_i = P(i)$.\n\n3. **Secret Reconstruction:**\n    *   Per ricostruire il segreto, sono necessarie almeno $k$ **shares** $(x_i, y_i)$.\n    *   Utilizza l'**interpolation** di Lagrange per ricostruire il polinomio $P(x)$ a partire dai $k$ punti. La formula di Lagrange è:\n\n    $$P(x) = \\sum_{i=1}^{k} y_i \\prod_{j=1, j \\neq i}^{k} \\frac{x - x_j}{x_i - x_j}$$\n\n    *   Una volta ricostruito il polinomio $P(x)$, il segreto $S$ può essere ottenuto valutando il polinomio in $x=0$:\n\n    $$S = P(0)$$\n\n**Esempio (semplificato):**\n\n*   Segreto: $S = 1234$\n*   Numero di **shares**: $n = 5$\n*   **Threshold**: $k = 3$\n*   Numero primo: $p = 1613$ (maggiore di $S$ e $n$)\n\n**Share Generation:**\n\n*   Scegliamo casualmente $k-1 = 2$ coefficienti: $a_1 = 166$, $a_2 = 94$.\n*   Il polinomio è: $P(x) = 1234 + 166x + 94x^2$.\n*   Generiamo 5 **shares**:\n    *   $P(1) = 1234 + 166 \\cdot 1 + 94 \\cdot 1^2 = 1494 \\pmod{1613}$  ->  $(1, 1494)$\n    *   $P(2) = 1234 + 166 \\cdot 2 + 94 \\cdot 2^2 = 1942 \\equiv 329 \\pmod{1613}$  ->  $(2, 329)$\n    *   $P(3) = 1234 + 166 \\cdot 3 + 94 \\cdot 3^2 = 2578 \\equiv 965 \\pmod{1613}$  ->  $(3, 965)$\n    *   $P(4) = 1234 + 166 \\cdot 4 + 94 \\cdot 4^2 = 3402 \\equiv 176 \\pmod{1613}$  ->  $(4, 176)$\n    *   $P(5) = 1234 + 166 \\cdot 5 + 94 \\cdot 5^2 = 4414 \\equiv 1188 \\pmod{1613}$ ->  $(5, 1188)$\n\n**Secret Reconstruction:**\n\nSupponiamo di avere le **shares**: $(1, 1494)$, $(3, 965)$, $(5, 1188)$.\n\n*   Usiamo l'**interpolation** di Lagrange per ricostruire il polinomio.\n*   Dopo aver eseguito i calcoli (omessi per brevità), otteniamo $P(x) = 1234 + 166x + 94x^2$.\n*   Il segreto è $S = P(0) = 1234$.\n\n**Proprietà di sicurezza:**\n\n*   **Information-Theoretically Secure:** Con meno di $k$ **shares**, non si ottiene alcuna informazione sul segreto. Questo perché qualsiasi valore del segreto è ugualmente probabile, dato un numero insufficiente di punti per determinare univocamente il polinomio.\n*   **Perfect Secret Sharing:** Ogni **share** è grande quanto il segreto originale.\n\n**Limitazioni:**\n\n*   **Share Size:** Ogni **share** ha la stessa dimensione del segreto. Questo può essere problematico se il segreto è molto grande, per esempio un file.\n*   **Dealer Trust:** Il **dealer** (chi genera le **shares**) conosce il segreto e deve essere fidato. E dunque potenzialmente rende questo inusabile in contesti come blockchain dove si potrebbe volere uno schema meno lasco dove la chiave privata (il segreto) non viene mai veramente materializzata completamente. \n*   **Static Threshold:** Il valore di $k$ (il **threshold**) è fissato al momento della generazione delle **shares**. Ovvero se aumentano o diminuiscono i partecipanti bisogna rifare tutto sto giro da capo.\n\n**Conclusioni:**\n\nWow. Che figata, loso. Lo Shamir's Secret Sharing è alla fine un algoritmo decisamente potent per la condivisione di segreti o chiavi private. Nonostante alcune limitazioni, rimane uno schema fondamentale nel campo della crittografia e della sicurezza informatica.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"sss.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":"cosmo","title":"Shamir's Secret Sharing","author":"Luca Simonetti","date":"2025-01-30","categories":["programming","web development"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}